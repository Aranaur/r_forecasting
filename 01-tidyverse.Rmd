# Вступ у Tidyverse {#tidy_verse}
***
```{r echo = FALSE, purl = FALSE, cache = FALSE, include=FALSE}
knitr::opts_knit$set(global.par = TRUE)
knitr::opts_chunk$set(warning = FALSE, message = FALSE, collapse = TRUE, out.width = '100%', fig.align='center')
library(tidyverse)
library(vroom)
library(gapminder)
library(readxl)
```
##  Tidy-всесвіт {#tidy}
***
[**Tidyverse**](https://www.tidyverse.org/) --- це екосистема, набір пакетів, які спеціально створені для науки про дані (data science). В ньому є ключові пакети (ядро tidyverse) та побічні --- які додатково розширюють можливості мови програмування R.

**Концепція охайних даних (tidy-data)** передбачає приведення даних до формату, в якому:

- Кожна змінна міститься в окремому стовпчику

- Кожне спостереження міститься в окремому рядку

- Кожне значення міститься в окремій комірці

**Ядро tidyverse:**

- **ggplot2**, для візуалізації

- **dplyr**, для маніпуляції з даними

- **tidyr**, для отримання охайних даних (tidy data)

- **readr**, для зчитування та записування файлів в R

- **purrr**, для функціонального програмування

- **tibble**, для роботи з тібблами (tibble), просунутий варіант дата фреймів

- **stringr**, для роботи з текстовими даними

- **forcats**, для роботи з факторами (factors)

Крім того є ще низка допоміжних пакетів, які не входять до ядра tidyverse але вважаються його частиною:

- **vroom**, для швидкого завантаження даних

- **DBI**, для роботи з базами даних

- **haven**, для даних SPSS, Stata та SAS

- **httr**, для роботи з API

- **readxl** для завантаження .xls та .xlsx файлів

- **googlesheets4**, для роботи з Google Sheet

- **googledrive**, для роботи з Google Drive

- **rvest**, для скрапінгу веб-сторінок

- **jsonlite**, для роботи з JSON-файлами

- **xml2**, для роботи з XML

- **lubridate**, для роботи з датами

- **dbplyr**, для перетворення коду `dplyr` в SQL

- **dtplyr**, для перетворення коду на `data.table`

- **magrittr**, для використання конвеєрів `%>%` (pipe)

- **glue**, для поєднання даних та тексту

- **tidymodels**, для роботи з моделями манинного навчання.

І це ще не повний список. Крім офіційних пакетів tidyverse є ще низка пакетів, які намагаються відповідати принципам tidyverse і доповнюють його.

Для завантаження tidyverse необхідно виконати наступний код:
```{r eval=FALSE}
install.packages("tidyverse")
```
Для підключення:
```{r eval=FALSE}
library("tidyverse")
```

## Завантаження даних {#tidy_read}
***
### Завантаження .csv, .tsv файлів {#tidy_csv}
Стандартною функцією завантаження даних типу `.csv` є функція `read.csv()`, але на досить великих масивах даних краще використовувати `read_csv()` з пакету `readr`. Синтаксис цих функцій схожий, але `read_csv()` одразу приведе дані до формату `tibble`.
Першим аргументом функції є шлях до файлу (зі оберненим слешем `/`), в тому числі URL-посилання: 
```{r eval=FALSE}
read_file <- read_csv("docs/data/file.csv")
read_url <- read_csv("https://git.io/JztOr")
```

Аналогічно до `read_csv()` можна використовувати функцію `vroom` з однойменного пакету. Головною особливістю цього пакету є [швидкість завантаження даних](https://cran.r-project.org/web/packages/vroom/vignettes/benchmarks.html).
```{r eval=FALSE}
vroom_file <- vroom("docs/data/file.csv")
vroom_url <- vroom("https://git.io/JztOr")
```

Для **завантаження** одночасно **декількох файлів однакової структури** корисно використовувати наступну конструкцію
```{r eval=FALSE}
filse <- dir(pattern = "\\.csv$")
vroom_all <- vroom(filse)
```

### Завантаження .xls, .xlsx файлів {#tidy_xls}
Для завантаження файлів **Excel** використовується пакет `readxl` та функція `read_excel()`.
На початку можна отримати перелік листів файлу Excel за допомогою функції `excel_sheets()`
```{r}
readxl::excel_sheets("docs/data/tourism.xlsx")
```
Після чого зчитати данні з потрібного листа
```{r eval=FALSE}
excel_file <- read_excel("docs/data/tourism.xlsx", sheet = "Sheet1")
```

В більшості випадків цього інструментарію має бути достатньо, але для завантаження специфічних файлів завжди можна знайти потрібний пакет. Не соромтеся використовувати google.


## Маніпуляції з даними за допомогою пакету `dplyr` {#tidy_dplyr}
***
`dplyr` --- це один з найголовніших пакетів `tidyverse`. Головний його функціонал --- це різноманітні маніпуляції з даними:

- фільтрація даних --- `filter()`

- впорядкування даних --- `arrange()`

- вибір змінних --- `select()`

- створення нових змінних --- `mutate()`

- групування даних --- `group_by`

- агрегування даних --- `summarise()`

### Фільтрація рядків - `filter()` {#tidy_filter}
Функція `filter()` дозволяє формувати підвибірки даних на основі їх значень. Її перший аргумент --- ім'я дата фрейму, другий і наступні --- умови фільтрації.

Розберемо на прикладі датасету `gapmainder` з однойменного пакету (див. таб. \@ref(tab:gapminder)). В ньому збережена інформація про ВВП, очікувану тривалість життя при народженні та населення для 142 країн світу з 1952 по 2007 роки.
```{r gapminder, echo=FALSE}
gapminder %>% 
  head() %>% 
  knitr::kable(caption = "Перші шість значень датасету gapminder")
```
Перш за все підключимо необхідні пакети:
```{r eval=FALSE}
library(gapminder)
library(dplyr)
```

Виконаємо просту фільтрацію з однією умовою:
```{r}
filter(gapminder, year == 2007)
```

Фільтрація з декількома умовами:
```{r}
filter(gapminder, year == 2007, continent == "Europe")
```
Умов фільтрації можна додавати безліч, їх можна перелічити через кому. Але створювати складні фільтрації можна у більш компактній формі. Для цього можна використати оператори: "ТА" (`&`), "АБО" (`|`), "НЕ" (`!`), а також функцію `xor()`, яка виключає АБО:
```{r}
filter(gapminder, year == 2007 & country == "New Zealand")

filter(gapminder, year == 2002 | year == 2007)
```

Ще один зручний спосіб формування складного фільтру --- використання виразу `x %in% y`, який фільтрує всі значення в яких `x` є одним із значень серед `y`:
```{r}
filter(gapminder, year == 2007 & country %in% c("New Zealand", "Poland", "Ireland"))
```

### Відбір стовпчиків - `select()` {#tidy_select}
Функція `select()` дозволяє відібрати тільки ті змінні, які нас цікавлять. Як і минулого разу, перший аргумент функції --- це дата фрейм, наступний --- обрані стовпці:
```{r}
select(gapminder, country, year, gdpPercap)
```
Крім того не обов'язково вказувати назви змінних, можна вказувати їх **порядковий номер**:
```{r}
select(gapminder, 1, 3, 5)
```
Або вказувати їх **послідовність у векторі**:
```{r}
select(gapminder, c(1, 4:6))
```
Аналогічно, послідовність буде працювати і для назв стовпців:
```{r}
select(gapminder, c(country, lifeExp:gdpPercap))
```
Функція `everything()` повертає всі стовпчики, але не буде повертати вже обрані стовпчики. Тому її можна використовувати для **зміни позицій змінних** в дата фреймі. Хоча в більшості випадків зручніше для таких задач використовувати функцію `relocate()`.
```{r}
select(gapminder, continent, everything())
```
За допомогою таких функцій як `starts_with()`, `ends_with()`, `contains()`, `matches()` можна **відбирати стовпчики за певним патерном у назві**.

Виберемо стовпчики, назва яких починається на латинську літеру "*с*"
```{r}
select(gapminder, starts_with("c"))
```
Або стовпчики, назва яких закінчується на латинську літеру "*p*"
```{r}
select(gapminder, ends_with("p"))
```
Стовпчики, назва яких містить на латинську літеру "*o*"
```{r}
select(gapminder, contains("o"))
```
Функція `matches()` використовується для відбору за регулярними виразами, з якими можна ознайомитися у книзі "Mastering Regular Expressions" [@friedl2006].

Відбір стовпчиків за їх типом даних виконується за допомогою функції `select_if()`:
```{r}
select_if(gapminder, is.numeric)
```

### Зміна назви стовпчиків - `rename()` {#tidy_rename}
Для зміни назви стовпчиків використовується функція `rename()`. Синтаксис функції: `нова_назва = стара_назва`.
```{r}
rename(gapminder, population = pop)
```
Замість старої назви можна вказати порядковий номер стовпчика:
```{r}
rename(gapminder, population = 5)
```
Змінити назву стовпчика за певною умовою можна за допомогою функції `rename_with()`. Наприклад, записати всі назви великими літерами:
```{r}
rename_with(gapminder, toupper)
```
Стовпчики, які починаються на латинську "*c*" записати великими літерами:
```{r}
rename_with(gapminder, toupper, starts_with("c"))
```
Більш складний варіант, але дуже часто вживаний --- заміна певного символу або частини в назві. Такі варіанти зустрічаються, коли в назвах стовпчиків зустрічаються зайві "пробіли". В нашому дата фреймі з цим все добре, але для прикладу замінемо всі "*co*" на "*CO*"
```{r}
rename_with(gapminder, ~ gsub("co", "CO", .x))
```

### Використання пайпів - `%>%` {#tidy_pipe}
**Пайпи** (pipes) --- це потужний та зручний інструмент для **чіткого опису послідовності операцій**. Для пояснення зручності його використання розглянемо два варіанти запису одного і того ж коду. Ті хто працював в Excel зараз згадають весь той біль.

**Вкладена функція**, як в Excel:
```{r}
rename_with(select_if(filter(gapminder, country == "Ireland"), is.numeric), toupper)
```
Той самий код з використанням `%>%`:
```{r}
gapminder %>% 
  filter(country == "Ireland") %>% 
  select_if(is.numeric) %>% 
  rename_with(toupper)
```
Погодьтеся, що другий варіант читається значно легше. Пайп працює наступним чином: він приймає результат виконання попереднього коду та передає його в якості першого аргументу наступній функції, такий собі конвєер. При цьому кожну наступну функцію ми можемо писати з наступного рядка.

Взагалі, з приводу **оформлення tidy-коду** бажано ознайомитися з матеріалами Хедлі Вікема [@hadley_style]

> Майже весь наступний код я буду писати вже з використанням `%>%`.

### Створення нових стовпчиків - `mutate()` {#tidy_mutate}
Для створення нових стовпчиків використовується функція `mutate()`. Вона завжди додає нові стовпчики в кінець дата фрейму.

Розрахуємо загальний **ВВП країни світу в мільярдах доларів США** та додамо ще одну змінну `country_group`, яка буде характеризувати рівень ВВП країни (більше 250 млрд --- високий, менше --- нормальний). Для цього перемножимо ВВП на душу населення на кількість населення та поділимо на 1000000000, після чого використаємо функцію if_else (аналог "=ЕСЛИ" з Excel).
```{r}
gapminder %>% 
  mutate(GDP_billion = gdpPercap * pop / 10^9,
         country_group = if_else(GDP_billion > 250, "hight_gpd", "normal_gdp")) %>% 
  filter(year == 2007)
```
Звертаю увагу, що останній стовпчик *country_group* був створений за допомогою попереднього нового стовпчика *GDP_billion*.

Також можна проводити різноманітні маніпуляції з цілою низкою стовпчиків за допомогою функцій `across()` та `where()`. Наприклад, розрахуємо натуральний логарифм до всіх числових стовпчиків:
```{r}
gapminder %>% 
  mutate(across(where(is.numeric), log))
```
Або запишемо всі категоріальні змінні з великої літери:
```{r}
gapminder %>% 
  mutate(across(where(is.factor), toupper))
```
Для того, щоб залишити лише "новостворені" стовпчики використовується функція `tranmutate()`:
```{r}
gapminder %>% 
  transmute(GDP_billion = gdpPercap * pop / 10^9)
```

### Групування даних - `group_by()` {#tidy_group}

### Агрегація даних - `group_by()` {#tidy_summarise}






## Створення звітів: R Markdown {#r_mark}
***
